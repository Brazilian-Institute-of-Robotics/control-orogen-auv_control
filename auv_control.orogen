name "auv_control"
version "0.2"

import_types_from "base"
import_types_from "6dControl.hpp"
using_library "motor_controller"

# Definition of the base interface for all AUV control components
#
# It also implements the base functionality of merging and validating the
# declared inputs, as well as managing the command input ports.
task_context "Base" do
    needs_configuration
    abstract

    # This property defines which parts of the command input is expected to be
    # set once we merged all the declared input ports. 
    property "expected_inputs", "auv_control::ExpectedInputs"
    
    # If true, the component will send a zero command before getting into an
    # exception state. Otherwise, it will not do anything
    property "keep_position_on_exception", "bool", true
    
    # The target state for this controller
    # 
    # This port is statically defined for simplicity reasons, additional ports
    # can be created using the addCommandInput operation
    input_port("cmd_in", "base::LinearAngular6DCommand")
    
    # This property defines the timeout for the cmd_in input port in seconds. 0
    # means that the timeout would be ignored.
    property "timeout_in", "double", 1

    # When used in a cascade, this input port can be used to feed the output of
    # the controllers before.
    #
    # Leave unconnected if you are not cascading controllers
    #
    # This port is statically defined for simplicity reasons, additional ports
    # can be created using the addCommandInput operation
    input_port('cmd_cascade', 'base::LinearAngular6DCommand')
    
    # This property defines the timeout for the cascade input port in seconds. 0
    # means that the timeout would be ignored.
    property "timeout_cascade", "double", 1
    
    # Create a new input to merge 
    #
    # Returns true if the port got added, and false if a port with the same name
    # already exists
    operation("addCommandInput").
        argument("name", "string").
        argument("timeout", "double").
        returns('bool')
    dynamic_input_port(/cmd_\w+/, "base::LinearAngular6DCommand")    

    # Averaged periods of the input commands
    output_port "avg_period", "base::LinearAngular6DCommand"

    runtime_states :WAIT_FOR_INPUT
    exception_states :INPUT_MISSING, :INPUT_COLLIDING, :INPUT_UNEXPECTED, :TIMEOUT

    # Deployed with a 10ms period by default
    periodic 0.01
end

# Base implementation of all the tasks that use one PID controller per axis to
# generate commands
task_context 'BasePIDController' do
    abstract
    subclasses "Base"

    # Settings for the PID controllers
    property "pid_settings", "base::LinearAngular6DPIDSettings"

    # The system state. Only the parts of the state that are controlled needs to
    # be available (i.e. if the command involves only orientation, only the
    # orientation part is really needed)
    input_port 'pose_samples', 'base::samples::RigidBodyState'

    # The output command. It is a velocity command expressed in the aligned
    # frame.
    output_port 'cmd_out', 'base::LinearAngular6DCommand'
end

# Controller that takes either positions or velocities, expressed in either the
# world or aligned frames, and outputs "whatever" in the same frame
task_context "PIDController" do
    subclasses "BasePIDController"

    # The command domain (true:position or false:velocity)
    property "position_control", "bool"
    # The command frame (true:world or false:aligned)
    property "world_frame", "bool"
end

# Task that get a target position in the world frame and outputs a position
# command in the aligned frame
#
# Note that this task expects to either have both x,y inputs or none. Giving it
# only X or only Y will result in a failure to start.
task_context "WorldToAligned" do
    subclasses "Base"

    # The domain of what we are converting (true:position or false:velocity or
    # efforts)
    property "position_control", "bool"

    # The system state. What is required depends on which parts of the state are
    # given as input
    input_port 'pose_samples', 'base::samples::RigidBodyState'

    # The output command.
    output_port 'cmd_out', 'base::LinearAngular6DCommand'
end

# Controller that takes either velocities or efforts expressed in the aligned
# frame as input and outputs the same commands, but expressed in the body frame.
task_context "AlignedToBody" do
    subclasses "Base"

    # The system's state. Only the orientation is being used (to be more
    # precise, only the pitch and roll angles)
    input_port 'orientation_samples', 'base::samples::RigidBodyState'

    # The output command. It is expressed in the body frame, and is of the same
    # nature than the input (efforts if the inputs are efforts, velocities if
    # the inputs are velocities)
    output_port 'cmd_out', 'base::LinearAngular6DCommand'
end

# Generates thruster commands based on a thruster matrix and a force-torque
# input expressed in the system's body frame.
#
# It assumes zero values on the axis that are not set
#
# It basically projects the (merged) input vector onto the thrusters using the
# matrix
task_context "AccelerationController" do
    subclasses "Base"

    # Matrix with size of 6 * n. n means the count of thrusters that are used.
    # The rows 0 to 2 of the matrix are the linear axis. The lines 3 to 5 of the
    # matrix are the angular axis.
    property "matrix", "base::MatrixXd"

    # Limits of the thrusters
    #
    # Leave empty if you don't want to limit anything (is that really a good
    # idea ?)
    property "limits", "base::JointLimits"

    # Lists which command parameter are being controlled on a per-joint basis.
    #
    # If left empty, uses RAW by default
    property "control_modes", "std::vector<base::JointState::MODE>"
    
    # Generated motor commands
    output_port "cmd_out", "base::commands::Joints"
end

# Generates a single constant command in the configured domain
task_context "ConstantCommand" do
    # The desired command
    property 'cmd', 'base/LinearAngular6DCommand'

    # The output command.
    output_port 'cmd_out', 'base::LinearAngular6DCommand'
end

# Follows a set of waypoints, where each waypoint is defined 
task_context "WaypointNavigator" do
    needs_configuration

    # The trajectory to follow, expressed as a set of waypoints in the world
    # frame
    input_port "trajectory", "std::vector<base::LinearAngular6DWaypoint>"
    
    # The current system pose
    input_port "pose_sample", "base::samples::RigidBodyState"

    # The output command, as a pose in world frame that can be used by the
    # auv_control controllers
    output_port "cmd_out", "base::LinearAngular6DCommand"
    
    ### MERGE ALL THESE INTO A SINGLE DATA STRUCTURE AND THEN MAKE A SINGLE PORT
    output_port("current_delta", "base::LinearAngular6DCommand").
        doc("shows error between current and desired waypoint for debugging")

    output_port("current_waypoint", "base::LinearAngular6DWaypoint").
        doc("current waypoint that is navigated by this controller")

    output_port("queue_size", "int").
        doc("remaining waypoints to follow")

    runtime_states :WAIT_FOR_WAYPOINTS, :KEEP_WAYPOINT,
        :FOLLOWING_WAYPOINTS, :POSE_SAMPLE_MISSING

    periodic(0.01)
end

# Task to convert MotionCommand2D into a velocity
#
# This allows to reuse control algorithms that deal with 2D motions (such as the
# trajectory_follower)
task_context "MotionCommand2DConverter" do
    needs_configuration

    # Command input as a velocity motion in the plan
    input_port "cmd_in", "base::MotionCommand2D"
    # Command output as an aligned velocity. Only the heading and X velocities
    # are set
    output_port "cmd_out", "base::LinearAngular6DCommand"

    port_driven "cmd_in"
end

